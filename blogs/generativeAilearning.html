<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>My Learning Journey in Generative AI | Siddharth Suryawanshi</title>

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background-color: #0f172a;
      color: #e5e7eb;
      margin: 0;
      line-height: 1.7;
    }

    .container {
      max-width: 900px;
      margin: auto;
      padding: 40px 20px;
    }

    h1 {
      font-size: 2.4rem;
      margin-bottom: 12px;
      color: #f8fafc;
    }

    h2 {
      margin-top: 42px;
      font-size: 1.6rem;
      color: #f1f5f9;
      border-bottom: 1px solid #334155;
      padding-bottom: 8px;
    }

    h3 {
      margin-top: 28px;
      font-size: 1.2rem;
      color: #e5e7eb;
    }

    p {
      color: #cbd5f5;
    }

    ul {
      padding-left: 20px;
    }

    li {
      margin-bottom: 10px;
      color: #cbd5f5;
    }

    strong {
      color: #f8fafc;
    }

    pre {
      background: #020617;
      border: 1px solid #1e293b;
      padding: 16px;
      border-radius: 10px;
      color: #e5e7eb;
      overflow-x: auto;
    }

    hr {
      border: none;
      border-top: 1px solid #334155;
      margin: 40px 0;
    }

    .meta {
      color: #94a3b8;
      font-size: 0.9rem;
      margin-bottom: 24px;
    }

    .back {
      display: inline-block;
      margin-top: 40px;
      text-decoration: none;
      color: #60a5fa;
      font-weight: 500;
    }

    .back:hover {
      text-decoration: underline;
    }
  </style>
</head>

<body>
  <div class="container">

    <a href="../index.html" class="back">← Back to Home</a>

    <h1>My Learning Journey in Generative AI: LangChain, RAG, and AI Agents</h1>

    <p class="meta">
      Generative AI · LangChain · Retrieval-Augmented Generation · AI Agents
    </p>

    <hr/>

    <h2>Introduction</h2>
    <p>
      Generative AI systems today go far beyond simple prompt-based interactions.
      Real-world applications require structured workflows, access to external
      knowledge, tool usage, and autonomous reasoning.
    </p>
    <p>
      As part of my learning journey, I explored <strong>LangChain</strong>,
      <strong>Retrieval-Augmented Generation (RAG)</strong>, and
      <strong>AI Agents</strong>, focusing on why these abstractions exist and
      how they are used in production-grade systems.
    </p>

    <h2>LangChain: Building Blocks for LLM Applications</h2>

    <h3>Why LangChain Exists</h3>
    <ul>
      <li>LLMs are stateless by default</li>
      <li>Difficult to orchestrate multi-step workflows</li>
      <li>No native support for tools, memory, or external data</li>
    </ul>
    <p>
      LangChain introduces standardized abstractions that make LLM applications
      modular, composable, and production-ready.
    </p>

    <h3>Core LangChain Components</h3>
    <ul>
      <li><strong>Models:</strong> LLMs, chat models, and embedding models</li>
      <li><strong>Prompts:</strong> Templates with dynamic variables</li>
      <li><strong>Messages:</strong> System, Human, AI, and Tool messages</li>
    </ul>

    <h3>Messages</h3>
    <p>
      Messages formalize conversation structure and enable multi-turn reasoning,
      tool calling, and agent execution.
    </p>

    <h3>Structured Outputs</h3>
    <p>
      Structured outputs enforce schemas such as JSON or Pydantic models,
      ensuring predictable and machine-readable responses.
    </p>
    <ul>
      <li>Reliable API responses</li>
      <li>Safe database writes</li>
      <li>Automation-ready outputs</li>
    </ul>

    <h3>Runnables (Why They Were Introduced)</h3>
    <p>
      Traditional chains were rigid and difficult to compose. Runnables were
      introduced to standardize execution, enable composability, and support
      streaming, batching, retries, and observability.
    </p>
    <ul>
      <li>RunnableSequence</li>
      <li>RunnableLambda</li>
      <li>RunnableParallel</li>
    </ul>

    <h2>Retrieval-Augmented Generation (RAG)</h2>

    <h3>Why RAG Is Needed</h3>
    <ul>
      <li>LLMs hallucinate</li>
      <li>Knowledge cutoffs exist</li>
      <li>Private or real-time data is inaccessible</li>
    </ul>

    <p>
      RAG grounds LLM responses using external, trusted data sources.
    </p>

    <h3>RAG Pipeline</h3>
    <pre>
Document → Chunk → Embed → Store → Retrieve → Generate
    </pre>

    <h3>Document Loaders</h3>
    <ul>
      <li><strong>Load:</strong> Loads all documents into memory</li>
      <li><strong>LazyLoad:</strong> Streams documents incrementally</li>
    </ul>

    <h3>Text Splitters</h3>
    <p>
      Split documents into semantically meaningful chunks using character,
      token, or recursive strategies.
    </p>

    <h3>Vector Stores</h3>
    <p>
      Vector databases store embeddings for fast similarity search.
    </p>

    <h3>Retrievers</h3>
    <ul>
      <li>Similarity-based retrievers</li>
      <li>MMR retrievers</li>
      <li>Self-query retrievers</li>
      <li>Multi-query retrievers</li>
    </ul>

    <h2>Tools in LangChain</h2>

    <h3>Types of Tools</h3>
    <ul>
      <li>Built-in tools</li>
      <li>Custom tools</li>
      <li>Toolkits</li>
    </ul>

    <h3>Tool Binding, Calling, and Execution</h3>
    <p>
      Tools are bound to models, selected dynamically by the LLM, executed by
      the system, and fed back into the reasoning loop.
    </p>

    <h2>AI Agents</h2>

    <h3>What Is an Agent?</h3>
    <p>
      An agent is an LLM capable of reasoning, choosing tools, taking actions,
      and iterating until a goal is achieved.
    </p>

    <h3>Agent Executor</h3>
    <p>
      The agent executor manages the execution loop, tracks intermediate steps,
      and applies stopping conditions.
    </p>

    <h3>ReAct Agent Workflow</h3>
    <pre>
User Query
   ↓
Agent Thinks
   ↓
Selects Tool
   ↓
Executes Tool
   ↓
Observes Result
   ↓
Thinks Again
   ↓
Final Answer
    </pre>

    <h2>Key Learnings</h2>
    <ul>
      <li>LLMs require structure, not just prompts</li>
      <li>RAG improves accuracy and trust</li>
      <li>Tools enable real-world interaction</li>
      <li>Agents allow autonomous workflows</li>
      <li>LangChain simplifies complex AI systems</li>
    </ul>

    <h2>Conclusion</h2>
    <p>
      Studying LangChain, RAG, and AI Agents helped me move from prompt engineering
      to system-level AI thinking. These concepts form the foundation of modern
      AI products such as copilots, chatbots, and autonomous assistants.
    </p>

    <a href="../index.html" class="back">← Back to Home</a>

  </div>
</body>
</html>
